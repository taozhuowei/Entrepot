[toc]



# 网络基础

## HTTP1.0 \ 1.1 \ 2.0区别

### HTTP 1.0

* 增加头部设定，头部内容为键值对
* 请求头通过Accept字段告诉服务器可以接收的文件类型
* 相应头通过Content-Type字段告诉浏览器返回文件的类型
* 每次通信需经过 建立连接—>传输数据—->断开连接，增加大量网络开销

### HTTP 1.1

* 新增持久化连接，减少连接带来的性能消耗
* 请求最大并发受限制（同域下6-8个）
* 一个TCP连接同一时刻只能处理一个请求

### HTTP 2.0

* 增加【多路复用】机制，不受限与浏览器的连接数限制
* 以二进制传输（HTTP1.x基于文本），保证健壮性
* 头信息压缩，提高效率

## HTTP请求

> HTTP请求包含*请求行* *请求报头* *空行*  *请求正文*

### 请求行

**格式** Method Request-URL HTTP-Version CRLF

 e.g. GET index.html HTTP/1.1

### 请求方法： GET & POST

* GET请求可被缓存，POST请求不会被缓存

* GET请求会保留在浏览器历史记录中，POST不会

* GET请求可被收藏为书签，POST不会

* GET请求不应该处理敏感数据，因为参数会暴露在url上

  POST可以处理敏感数据，参数会携带在请求体中，不会在url上

* GET请求有长度限制，POST没有

* GET只可以传ASCII字符，POST没有类型限制

### 常见HTTP请求头

* **Accept**

  可接受的相应内容类型

* **Accept-Charset**

  可接受的字符集

* **Accept-Encoding**

  可接受的相应内容的编码方式

* **Accept-Language**

  可接受的相应内容的语言的列表

* **Cache-Control**

  是否使用缓存机制

* **Content-Type**

  POST\PUT请求中，请求体的MIME类型

* **Origin**

  发起CORS请求的源

* **Connection**

  设置为`keep-alive`可以在HTTP请求结束后不关闭TCP连接

##  HTTP响应

> HTTP响应包含 *状态码* *响应报头* *空行* *响应报文*

### 状态码

* **1xx** 指示信息

  请求已接收，继续处理

* **2xx** 成功

  请求已被成功接收、理解、接受

* **3xx** 重定向

  需要进一步操作以完成请求

* **4xx** 客户端错误

  请求语法错误 或 请求无法实现

* **5xx** 服务端错误

  服务器未能实现合法请求

### 常见状态码

#### 2xx

1. **200 OK** 

   请求正常处理并返回

2. **204 No Content**

   请求成功处理，但没有资源返回

3. **206 Patial Content**

   客户端进行了【范围请求】，服务器成功执行了这部分【GET请求】

   响应报文中包含由`Content-Range`指定范围的实体内容

#### 3xx

1. **301 Moved Permanently**

   永久性重定向

2. **302 Found**

   临时性重定向

3. **303 See Other**

   请求资源被分配了新URL，必须使用GET方法访问

4. **304 Not Modified**

   客户端发送【附带条件】^①^，服务端允许访问资源

   请求满足条件时返回该状态码

5. **307 Temporary Redirect**

   临时重定向，含义与【303】相同

   会遵照浏览器标准，不会从POST变成GET（视具体浏览器实现）

①附带条件：使用GET方法的请求报文中包含`If-Match`\`If-Modified-Since`\`If-Range`\`If-Unmodified-Since`任一头部

#### 4xx

1. **400 Bad Request**

   请求报文存在语法错误

2. **401 Unauthorized**

   未经许可，需要通过HTTP认证

3. **403 Forbidden**

   服务器拒绝访问

4. **404 Not Found**

   服务器无法找到请求的资源

   也可在服务器拒绝请求但不想给原因时使用

#### 5xx

1. **500 Inter Server Error**

   服务器执行请求错误

   或web应用存在bug

   或某些临时错误

2. **503 Server Unavailable**

   服务器维护或超负载，无法处理请求

### 常见HTTP响应头

* Access-Control-Allow-Origin

* Access-Control-Allow-Methods

* Access-Control-Allow-Credentials

* Access-Control-Allow-Headers

* Access-Control-Expose-Headers

* Access-Control-Max-Age

* Cache-Control

  通知从服务器到客户端内的所有缓存机制，表示是否可以缓存及有效时间，单位秒

  `Cache-Control：max-age=3600`

* Content-Encoding

* Content-Language

* Content-Type

* Status

## HTTP缓存

> HTTP缓存包括【强缓存】和【协商缓存】

**强缓存优先级高于协商缓存**

**缓存优点** 减小服务器压力，服务端不必重复发送某些资源，速度更快，用户体验更好

### 强缓存

> 加载时先查缓存，再请求服务器

**HTTP 1.0 使用 `Expires` 设置缓存时间**

第一次请求时，服务端在响应头添加Expires字段

之后的请求，比对当前时间和Expires时间，没过期用缓存，过期再请求

**HTTP 1.1 使用`Cache-Control : max-age=过期时间`设置缓存时间**

`max-age`优先级高于`Expires`

### 协商缓存

> 协商缓存不再指定有效时间，而是直接发送请求确认缓存是否更新，服务端返回304，则表示缓存有效

**对比资源修改时间**

* 第一次请求，服务端【响应头】添加`Last-Modified`字段，值为服务端【最后修改时间】
* 之后请求，【请求头】添加`If-Modified-Since`，值是上次服务端返回的【最后修改时间】
* 服务端收到请求，判断`If-Modified-Since`值
  * 资源未修改，返回304，不返回内容
  * 资源修改，返回内容，更新`Last-Modified`值

**对比资源哈希值**（优先使用）

哈希值由资源内容计算得出

* 第一次请求，服务端【响应头】添加`ETag`字段，值为【资源哈希值】
* 之后请求，【请求头】添加`If-None-Match`，值为上次服务端返回的【资源哈希值】
* 服务端收到请求，判断`If-None-Match`值
  * 资源内容无变化，返回304，不返回内容
  * 变化，返回内容，计算哈希值，更新`ETag`值

## HTTPS

### 与HTTP区别

|   区别   |                    HTTP                     |                      HTTPS                      |
| :------: | :-----------------------------------------: | :---------------------------------------------: |
|   协议   | TCP，明文传输，客户端服务端无法互相验证身份 | SSL（SSL运行在TCP上），是添加了加密和认证的HTTP |
|   端口   |                     80                      |                       443                       |
| 资源消耗 |                     少                      |                （由于加解密）多                 |
|   开销   |                  无需证书                   |              需要，向认证机构购买               |
| 加密机制 |                     无                      |    对密钥使用非对称加密，对内容使用对称加密     |
|  安全性  |                     弱                      |                       强                        |

**对称加密**

* 双方共用钥匙，对内容双向加解密
* 只要和服务器通信就能获得密钥，密钥也可解密其他通信数据
* 效率比非对称加密高，但没有他安全

**非对称加密**

* 生成【公钥】和【私钥】，服务端持有【私钥】，【公钥】对外公开
* 【公钥】加密【私钥】解，【私钥】加密【公钥】解
* 安全性高，效率低

**CA证书**

* 权威机构颁发，用于验证服务端合法性
* 内容包括： 颁发机构信息、公钥、公司信息、域名……

### 过程

1. 客户端向服务端发起HTTPS请求
2. 服务端返回HTTPS证书
3. 客户端验证证书合法性
   * 不合法—->提示告警
   * 合法—->在本地生成随机数
4. 公钥加密随机数，发送到服务端
5. 服务端用私钥解密随机数
6. 服务端使用随机数构造对称加密算法，对内容加密后传输
7. 客户端收到加密内容，使用本地随机数构建对称加密算法解密内容

## TCP三次握手

### 过程

1. **客户端 ——> 服务端**

   发起【连接请求报文】，报文带有【连接标识SYN】

2. **服务端 ——–> 客户端**

   服务器收到客户端请求，发现【SYN】

   回复【带有SYN的确认报文】

3. **客户端 ———-> 服务端**

   客户端收到服务端【回复确认报文】，确认服务端允许连接

   客户端回复【确认报文】给服务端

   服务端收到【确认报文】，建立TCP连接

### 为什么需要三次握手

> 如果是两次握手，在【第二次握手】时报文丢失，【客户端】不知道【服务端】是否准备好，不会发送数据，并忽略【服务端】发来的数据
>
> 三次握手时，如果出现报文丢失，则【服务端】在一定时间内没收到【客户端】的【带有SYN的确认报文】会重新进行【第二次握手】
>
> 三次握手主要考虑【丢包重连】问题

## TCP四次挥手

### 过程

1. **客户端 ——-> 服务端**

   客户端发送【连接释放报文】，携带【连接释放标识FIN】

   客户端此时不能发送数据，可以接受数据

2. **服务端 ——–> 客户端**

   服务端收到【连接释放报文】，回复【不带有FIN的确认报文】

   服务器进入【关闭等待】状态，持续一段时间，因为可能有数据没有发完

3. **服务端 ——–> 客户端**

   服务端所有数据发送完毕，发送【带有FIN的确认报文】给客户端

4. **客户端 ——-> 服务端**

   客户端收到【带有FIN的确认报文】，回复【确认报文】

   服务端收到【确认报文】立即释放TCP连接

   服务端结束TCP连接时间早于客户端

### 为什么需要需要四次挥手

> 【服务端】需要确保数据完整性，所以先回复【确认】，进入【关闭等待】状态，等待数据发送完毕，再回复【确认释放连接】

## TCP 与 UDP 区别

|               TCP                |                UDP                 |
| :------------------------------: | :--------------------------------: |
|             面向连接             |               无连接               |
|            一对一通信            |   一对一、一对多、多对一、多对多   |
|             面向报文             |             面向字节流             |
| 可靠传输，使用流量控制和拥塞控制 | 不可靠传输，没有流量控制和拥塞控制 |
|     报头最小20字节最大60字节     |             报头8字节              |

## TCP可靠的原因

* **数据包校验**

  检测数据在传输过程中的任何变化

  若校验包出错，则丢弃报文，不予响应

  超时后再次发送

* **重排序失序数据包**

  TCP报文段作为【IP数据报】传输，可能失序，TCP重排后交给应用层

* **丢弃重复数据**

* **应答机制**

  当收到连接另一端的数据，将推迟几分之一秒后发送确认

* **超时重发**

  发出一个报文段后，启动定时器

  等待客户端发送【确认收到】

  如果没有收到【确认收到】，重发报文段

* **流量控制**

  TCP连接每一方都有固定大小的缓存空间

  接收端只允许另一端发送能接受大小的数据，防止缓冲区溢出

* **拥塞控制**

  https://blog.csdn.net/qq_41431406/article/details/97926927

## TCP/IP 四层模型

**从下到上**

数据链路层 —— 网络层 ——传输层 ——应用层

## OSI 七层模型

**从下到上**

物理层 —— 数据链路层 —— 网络层 —— 传输层 —— 会话层 —— 表示层 —— 应用层

## 从【输入URL】到【页面加载完成】发生了什么

* 浏览器地址栏输入 URL ，按下回车

* 浏览器发送请求前

  根据请求头的`expires`和`cache-control`判断是否命中强缓存策略（是否过期）

  命中则直接从缓存获取资源，不进行请求

* 没有命中强缓存规则，则发送请求

  根据请求头的`last-modified`和`etag`判断是否命中协商缓存

  命中则从缓存获取资源，没有则进入下一步

* DNS解析

* 根据IP 进行 TCP连接

* 发起HTTP请求

* 服务器处理请求

* 浏览器接收HTTP响应

* 渲染页面（【浏览器】中【页面渲染流程】）

* 关闭TCP连接

## DNS 域名解析过程

* 检查本地HOSTS文件是否有映射

  * 有 —> 映射此IP

  * 没有 —> 查找本地DNS解析器缓存

    * 找到 —> 返回IP

    * 没找到 —> 查找本地DNS服务器

      * 找到 —> 返回IP

      * 没找到 —> 迭代查询

        根域服务器库（.com \ .cn ……) —> 顶级域.com —> 第二层子域(baidu.com) —> 找到IP

  

## 正向代理

> 代理真实客户，为客户端收发请求，真实客户端对服务器不可见。
>
> 局域网内所有用户可能被一台服务器做正向代理，由他负责HTTP请求。
>
> 同服务器通信的是正向代理服务器。

## 反向代理

> 代理服务器，为服务器收发请求，真实服务器对客户端不可见。
>
> 负载均衡服务器，可以将请求分发到空闲服务器上
>
> 用户和负载均衡服务器直接通信

