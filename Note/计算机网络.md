# **计算机网络**

## HTTP1.0 \ 1.1 \ 2.0 区别

### HTTP 1.0

* 增加头部设定，头部内容为键值对
* 请求头通过Accept字段告诉服务器可以接收的文件类型
* 相应头通过Content-Type字段告诉浏览器返回文件的类型
* 每次通信需经过 建立连接—>传输数据—->断开连接，增加大量网络开销

### HTTP 1.1

* 新增持久化连接，减少连接带来的性能消耗
* 请求最大并发受限制（同域下6-8个）
* 一个TCP连接同一时刻只能处理一个请求

### HTTP 2.0

* 增加【多路复用】机制，不受限与浏览器的连接数限制
* 以二进制传输（HTTP1.x基于文本），保证健壮性
* 头信息压缩，提高效率

## HTTP请求

> HTTP请求包含*请求行* *请求报头* *空行*  *请求正文*

### 常见HTTP请求

|  请求   |                   说明                   |
| :-----: | :--------------------------------------: |
|   GET   |                 获取数据                 |
|  POST   |                 提交数据                 |
|   PUT   |              提交数据以修改              |
|  HEAD   |       请求页面首部，获取资源元信息       |
| DELETE  |                 删除资源                 |
| CONNECT |       用于代理服务器，建立连接隧道       |
| OPTIONS | 用于跨域，获取可对资源实施的请求方法列表 |
|  TRACE  |         追踪请求-响应的传输路径          |

### 请求行

**格式** `Method Request-URL HTTP-Version CRLF`

 e.g. `GET index.html HTTP/1.1`

### 请求方法： GET & POST 的区别

|    区别    |        GET        |              POST               |
| :--------: | :---------------: | :-----------------------------: |
|    缓存    |     可被缓存      |           不会被缓存            |
|  历史记录  |       保留        |             不保留              |
|   安全性   |  参数暴露在URL上  | 数会携带在请求体中，不会在URL上 |
|  长度限制  |        有         |              没有               |
|  传输格式  | 只可以传ASCII字符 |          没有类型限制           |
|  编码方式  |  只能进行URL编码  |        支持多种编码方式         |
| 数据包数量 | 产生一个TCP数据包 |      可能产生两个TCP数据包      |

### 常见HTTP请求头

* **Accept**

  可接受的相应内容类型

* **Accept-Charset**

  可接受的字符集

* **Accept-Encoding**

  可接受的相应内容的编码方式

* **Accept-Language**

  可接受的相应内容的语言的列表

* **Cache-Control**

  是否使用缓存机制

* **Content-Type**

  POST\PUT请求中，请求体的MIME类型

* **Origin**

  发起CORS请求的源

* **Connection**

  设置为`keep-alive`可以在HTTP请求结束后不关闭TCP连接

##  HTTP响应

> HTTP响应包含 *状态码* *响应报头* *空行* *响应报文*

### 状态码

* **1xx** 指示信息

  请求已接收，继续处理

* **2xx** 成功

  请求已被成功接收、理解、接受

* **3xx** 重定向

  需要进一步操作以完成请求

* **4xx** 客户端错误

  请求语法错误 或 请求无法实现

* **5xx** 服务端错误

  服务器未能实现合法请求

### 常见状态码

#### 2xx

1. **200 OK** 

   请求正常处理并返回

2. **204 No Content**

   请求成功处理，但没有资源返回

3. **206 Patial Content**

   客户端进行了【范围请求】，服务器成功执行了这部分【GET请求】

   响应报文中包含由`Content-Range`指定范围的实体内容

#### 3xx

1. **301 Moved Permanently**

   永久性重定向

2. **302 Found**

   临时性重定向

3. **303 See Other**

   请求资源被分配了新URL，必须使用GET方法访问

4. **304 Not Modified**

   客户端发送【附带条件】^①^，服务端允许访问资源

   请求满足条件时返回该状态码

5. **307 Temporary Redirect**

   临时重定向，含义与【303】相同

   会遵照浏览器标准，不会从POST变成GET（视具体浏览器实现）

①附带条件：使用GET方法的请求报文中包含`If-Match`\`If-Modified-Since`\`If-Range`\`If-Unmodified-Since`任一头部

#### 4xx

1. **400 Bad Request**

   请求报文存在语法错误

2. **401 Unauthorized**

   未经许可，需要通过HTTP认证

3. **403 Forbidden**

   服务器拒绝访问

4. **404 Not Found**

   服务器无法找到请求的资源

   也可在服务器拒绝请求但不想给原因时使用

#### 5xx

1. **500 Inter Server Error**

   服务器执行请求错误

   或web应用存在bug

   或某些临时错误

2. **503 Server Unavailable**

   服务器维护或超负载，无法处理请求

### 常见HTTP响应头

* Access-Control-Allow-Origin

* Access-Control-Allow-Methods

* Access-Control-Allow-Credentials

* Access-Control-Allow-Headers

* Access-Control-Expose-Headers

* Access-Control-Max-Age

* Cache-Control

  通知从服务器到客户端内的所有缓存机制，表示是否可以缓存及有效时间，单位秒

  `Cache-Control：max-age=3600`

* Content-Encoding

* Content-Language

* Content-Type

* Status

## HTTP缓存

> HTTP缓存包括【强缓存】和【协商缓存】

**强缓存优先级高于协商缓存**

**缓存优点** 减小服务器压力，服务端不必重复发送某些资源，速度更快，用户体验更好

### 强缓存

> 加载时先查缓存，再请求服务器

**HTTP 1.0 使用 `Expires` 设置缓存时间**

第一次请求时，服务端在响应头添加Expires字段

之后的请求，比对当前时间和Expires时间，没过期用缓存，过期再请求

**HTTP 1.1 使用`Cache-Control : max-age=过期时间`设置缓存时间**

`max-age`优先级高于`Expires`

### 协商缓存

> 协商缓存不再指定有效时间，而是直接发送请求确认缓存是否更新，服务端返回304，则表示缓存有效

**对比资源哈希值**（优先使用）

哈希值由资源内容计算得出

* 第一次请求，服务端【响应头】添加`ETag`字段，值为【资源哈希值】
* 之后请求，【请求头】添加`If-None-Match`，值为上次服务端返回的【资源哈希值】
* 服务端收到请求，判断`If-None-Match`值
  * 资源内容无变化，返回304，不返回内容
  * 变化，返回内容，计算哈希值，更新`ETag`值

**对比资源修改时间**

* 第一次请求，服务端【响应头】添加`Last-Modified`字段，值为服务端【最后修改时间】
* 之后请求，【请求头】添加`If-Modified-Since`，值是上次服务端返回的【最后修改时间】
* 服务端收到请求，判断`If-Modified-Since`值
  * 资源未修改，返回304，不返回内容
  * 资源修改，返回内容，更新`Last-Modified`值

## HTTP 长连接

> HTTP分为长连接和短连接，本质上是TCP的长连接和短连接。
>
> TCP连接是一个双向通道，可以保持一段时间不关闭。
>
> TCP长连接可以复用一个TCP连接来发起多次HTTP请求。

### 实现方式

响应头设置`Connection = keep-alive`

HTTP 1.0 默认关闭长连接，HTTP 1.1 默认打开

### 设置超时

HTTP 中有一个守护进程，可以设置`keep-alive timeout`

当TCP 连接闲置超过这个值就会关闭，也可以在HTTP的header中设置

### keep-alive 的三个参数

* tcp_keepalive_time 当TCP连接闲置时间超过这个属性值，则会发送侦测包
* tcp_keepalive_intvl 当发送的侦测包没有ACK确认时，间隔这个属性值设定的时间再次发送
* tcp_keepalive_probes 当发送了这个属性值设定的个数的侦测包时，还没有回应，则丢弃该连接

## HTTPS

### HTTP 存在的问题

* 明文传输请求信息，易被窃听获取
* 不验证数据完整性，易被篡改
* 不验证对方身份，可冒充身份

### 与HTTP区别

|   区别   |                    HTTP                     |                      HTTPS                      |
| :------: | :-----------------------------------------: | :---------------------------------------------: |
|   协议   | TCP，明文传输，客户端服务端无法互相验证身份 | SSL（SSL运行在TCP上），是添加了加密和认证的HTTP |
|   端口   |                     80                      |                       443                       |
| 资源消耗 |                     少                      |                （由于加解密）多                 |
|   开销   |                  无需证书                   |              需要，向认证机构购买               |
| 加密机制 |                     无                      |    对密钥使用非对称加密，对内容使用对称加密     |
|  安全性  |                     弱                      |                       强                        |

**对称加密**

* 双方共用钥匙，对内容双向加解密
* 只要和服务器通信就能获得密钥，密钥也可解密其他通信数据
* 效率比非对称加密高，但没有他安全

**非对称加密**

* 生成【公钥】和【私钥】，服务端持有【私钥】，【公钥】对外公开
* 【公钥】加密【私钥】解，【私钥】加密【公钥】解
* 安全性高，效率低

**CA证书**

* 权威机构颁发，用于验证服务端合法性
* 内容包括： 颁发机构信息、公钥、公司信息、域名……

### 过程

1. 客户端向服务端发起HTTPS请求
2. 服务端返回HTTPS证书
3. 客户端验证证书合法性
   * 不合法—->提示告警
   * 合法—->在本地生成随机数
4. 客户端使用公钥加密随机数，发送到服务端
5. 服务端用私钥解密随机数
6. 服务端使用随机数构造对称加密算法，对内容加密后传输
7. 客户端收到加密内容，使用本地随机数构建对称加密算法解密内容

## HTTP 与 TCP 的区别与联系

* TCP 是传输层协议；HTTP 是应用层协议
* TCP 是传输控制协议；HTTP 是超文本传输协议
* HTTP 基于 TCP 连接之上
* TCP 只建立连接，不发送数据；HTTP 用于收发数据

## TCP三次握手

### 过程

起初，客户端处于CLOSED状态，服务端处于LISTEN状态

* 第一次握手

客户端向服务器发送【连接请求报文】，报文带有【连接标识SYN】和【客户端序列号seq】，此时客户端进入SYN_SEND状态

* 第二次握手

服务器收到客户端请求，发现【SYN】

服务器将收到的【序列号】加1作为【ACK】，连同【SYN】和自己的【服务器序列号seq】作为【回复确认报文】发送给服务器，此时服务器进入SYN_RECV状态，这个连接会进入半连接队列

* 第三次握手

客户端收到服务端【回复确认报文】，确认服务端允许连接

客户端将收到的【服务器序列号seq】加1作为ACK，向服务器发送携带【ACK】的【确认报文】

服务器收到【确认报文】，建立TCP连接

此时客户端和服务器均进入ESTABLISHED状态

此时可以传输数据（前两次握手不可以）

### 为什么需要三次握手

> 如果是两次握手，在第二次握手时报文丢失，客户端不知道服务端是否准备好，不会发送数据，并忽略服务端发来的数据
>
> 三次握手时，如果出现报文丢失，则服务端在一定时间内没收到客户端的确认报文会重新进行第二次握手
>
> 三次握手主要考虑**丢包重连**问题

## TCP四次挥手

### 过程

四次挥手可以由任意一方发起，以客户端发起为例

起初，客户端和服务器处于ESTABLISHED状态

* 第一次挥手

客户端发送【连接释放报文】，携带【连接释放标识FIN】和【客户端序列号seq】，此时客户端进入FIN-WAIT-1状态

客户端此时不能发送数据，可以接受数据

* 第二次挥手

服务端收到【连接释放报文】，回复【确认报文】，携带有值为【客户端序列号seq】加1的【ACK】和自己的【服务器序列号seq】，这个报文不携带【FIN】

服务器进入CLOSE-WAIT，也就是关闭等待状态，持续一段时间，因为可能有数据没有发完

* 第三次挥手

服务端所有数据发送完毕，发送【带有FIN的确认报文】给客户端，此时服务器进入LAST-ACK状态

* 第四次挥手

客户端收到【带有FIN的确认报文】，回复带有【服务器序列号seq】加1的【ACK】的【确认报文】，此时客户端进入TIME-WAIT状态

服务端收到【确认报文】立即释放TCP连接

客户端需要等待2MSL后进入CLOSED状态

因此服务端结束TCP连接时间早于客户端

### 客户端等待2MSL的原因

**2MSL （Maximum Segment Lifetime）两个最大段生命周期**

第一个周期可以保证四次挥手中，主动关闭方最后的ACK报文能送达

第二个周期可以保证对方没有收到ACK时重传的FIN报文可以送达

### 为什么需要需要四次挥手

> 【服务端】需要确保数据完整性，所以先回复【确认】，进入【关闭等待】状态，等待数据发送完毕，再回复【确认释放连接】

## TCP 与 UDP 区别

|               TCP                |                UDP                 |
| :------------------------------: | :--------------------------------: |
|             面向连接             |               无连接               |
|            一对一通信            |   一对一、一对多、多对一、多对多   |
|             面向报文             |             面向字节流             |
| 可靠传输，使用流量控制和拥塞控制 | 不可靠传输，没有流量控制和拥塞控制 |
|     报头最小20字节最大60字节     |             报头8字节              |

## TCP可靠的原因

* **数据包校验**

  检测数据在传输过程中的任何变化

  若校验包出错，则丢弃报文，不予响应

  超时后再次发送

* **重排序失序数据包**

  TCP报文段作为【IP数据报】传输，可能失序，TCP重排后交给应用层

* **丢弃重复数据**

* **应答机制**

  当收到连接另一端的数据，将推迟几分之一秒后发送确认

* **超时重发**

  发出一个报文段后，启动定时器

  等待客户端发送【确认收到】

  如果没有收到【确认收到】，重发报文段

* **流量控制**

  TCP连接每一方都有固定大小的缓存空间

  接收端只允许另一端发送能接受大小的数据，防止缓冲区溢出

* **拥塞控制**

## WebSocket & Socket

* Socket = IP + 端口 + 协议，是一套标准，完成了对TCP/IP的高度封装，屏蔽了网络细节以便开发者更好的进行网络编程
* WebSocket是一个持久化的协议，应用在应用层，用于持久化

## 计算机网络体系结构 

### OSI 七层模型

**从下到上**

> 物理层 —— 数据链路层 —— 网络层 —— 传输层 —— 会话层 —— 表示层 —— 应用层

**其中，会话层、表示层和应用层可以合并为应用层**

上述七层模型可简化为五层模型，即：

> 物理层 —— 数据链路层 —— 网络层 —— 传输层 —— 应用层

### TCP/IP 四层模型

**从下到上**

> 网络接口层 —— 网际层IP —— 传输层 —— 应用层

## 从【输入URL】到【页面加载完成】发生了什么

* 浏览器地址栏输入 URL ，按下回车

* 浏览器发送请求前

  根据请求头的`expires`和`cache-control`判断是否命中强缓存策略（是否过期）

  命中则直接从缓存获取资源，不进行请求

* 没有命中强缓存规则，则发送请求

  根据请求头的`last-modified`和`etag`判断是否命中协商缓存

  命中则从缓存获取资源，没有则进入下一步

* DNS解析

* 根据IP 进行 TCP连接 (三次握手)

* 发起HTTP请求

* 服务器处理请求

* 浏览器接收HTTP响应

* 渲染页面

* 关闭TCP连接 （四次挥手）

## DNS 域名解析过程

* 检查本地HOSTS文件是否有映射

  * 有 —> 映射此IP

  * 没有 —> 查找本地DNS解析器缓存

    * 找到 —> 返回IP

    * 没找到 —> 查找本地DNS服务器

      * 找到 —> 返回IP

      * 没找到 —> 迭代查询

        根域服务器库（.com \ .cn ……) —> 顶级域.com —> 第二层子域(baidu.com) —> 找到IP

## URL 与 URI

* URL（Uniform Resource Location)，统一资源定位符，类似住址，提供资源路径
* URI（Uniform Resource Identifier)，统一资源标识符，类似身份证，作为资源的唯一标识

## Cookie

> Cookie 是服务器发送到浏览器，并保存到浏览器的一小段文本串数据，它会在浏览器向同一服务器再次发送请求时被携带发送到服务器。

### 用途

* 会话状态管理 （登录状态、购物车、游戏分数等）
* 个性化设置（自定义设置、主题等）
* 浏览器行为跟踪（分析用户行为）

## Session

> Session 指客户端和服务器一次会话的过程。
>
> Session 使用Cookie处理信息，当用户首次请求时，服务器会在用户浏览器上创建一个Cookie，当Session结束时，Cookie过期。
>
> Session对象存储这特定用户会话所需的属性及配置信息。

## Cookie 和 Session 的区别

|    区别    |                      Cookie                      |     Session      |
| :--------: | :----------------------------------------------: | :--------------: |
|  存储位置  |                      浏览器                      |      服务器      |
|   安全性   |                不安全（XSS攻击）                 |       安全       |
|    性能    |                可以减轻服务器压力                | 会影响服务器性能 |
|  大小限制  |                     有（4K）                     |       没有       |
| 信息可见性 |              客户端服务器都可以知道              |  只被服务器知道  |
|  路径区分  | 可以区分路径，同一个网站不同路径下Cookie无法访问 |   不能区分路径   |
|  存储格式  |                      字符串                      |       对象       |

## Cookie 和 Session 如何配合

用户第一次请求服务器时，后端会创建对应的Session ， 请求返回时会将此Session的唯一标识——SessionId返回个客户端浏览器，浏览器将其存入Cookie，同时记录其属于哪个域名。

用户之后请求服务器时，请求会自动判断该域名下是否存在Cookie信息，如果有，则将其发送个服务器，服务器获取到其中的SessionId，查找到对应的Session信息，如果没有找到，则说明用户未登录或登录失效，找到则可以进行后续操作。

如果禁用了Cookie，可以在请求中携带SessionId或使用Token

## 正向代理

> 代理真实客户，为客户端收发请求，真实客户端对服务器不可见。
>
> 局域网内所有用户可能被一台服务器做正向代理，由他负责HTTP请求。
>
> 同服务器通信的是正向代理服务器。

## 反向代理

> 代理服务器，为服务器收发请求，真实服务器对客户端不可见。
>
> 负载均衡服务器，可以将请求分发到空闲服务器上
>
> 用户和负载均衡服务器直接通信

## Forward 和 Redirct区别

* Forward ，直接转发，只发送一次请求，由第二个资源响应该请求

  即 A 找到 B ，B 找到 C ，然后把C带给A

* Redirct ，间接转发，实际是两次请求，服务器让浏览器再请求一次

  即 A 找到 B ， B 让 A 去找 C

## 网络攻击

### XSS 攻击

> XSS （Cross Site Scription），跨站脚本攻击，指攻击者向Web页面中插入恶意HTML代码，当用户浏览该网页时会执行这段恶意代码。

#### XSS 攻击的三种类型

存储型 、 反射型 、DOM型

#### 预防方式

* 过滤用户输入
* HTML转义
* 校验链接跳转内容，禁止以`script`开头的非法链接
* 限制输入长度

### SQL 注入

> 一种代码注入技术，在Web应用接口中传入一些特殊参数字符，以此欺骗服务器执行恶意SQL命令，来获取系统信息。

#### 预防方式

* MyBatis中使用`#{}` 而不是`${}`。前者将参数用引号包裹，后者则直接处理参数。
* 不暴露不必要的日志或安全信息，避免响应SQL异常信息
* 用户输入过滤
* 用户权限校验

### DoS & DDoS & DRDoS 攻击

* DoS（Denial of Service），拒绝服务，一切能引起该行为的攻击都称为DoS攻击。常见的有计算机网络宽带攻击、连通性攻击
* DDoS（Distributed Reflection Denial of Service），分布式拒绝服务，指位于不同位置的多个攻击者同时攻击一个或数个目标，或者一个攻击者控制了不同位置的多台机器对目标同时进行攻击。常见的有SYN Flood 、 Ping of Death 、ACK Flood
* DRDoS（Distributed Reflection Denial of Service），分布式反射拒绝服务，改攻击方式靠大量带有被害者IP的数据包攻击主机，目标会对IP地址源做出大量回应，形成拒绝服务攻击。

### CSRF攻击

> CSRF（Cross-site Request Forgery），跨站请求伪造，攻击者盗用用户身份，并以此名义发送恶意请求。

XSS利用的是用户对网站的信任，CSRF利用的是网站对用户浏览器的信任

#### 解决方法

* 检测HTTP头中的Referer字段，该字段用于标明请求来源于哪个地址
* 添加校验token

